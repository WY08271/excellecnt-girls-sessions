##基于实战的软件学习方法

----

###前话
技术竞赛

* 3人组队制，不限制是否是实验室的人员
* 评比方式：代码是否整洁，提交的方式，测试情况等
* 内容都是公开课上讲过的知识


---
###学习方法

原因：自学方式不对，只读书看视频，不实践。每次都是拿着一本厚厚的工具书一页一页的看，但是真正遇到问题时候还是不知道怎么去解决。大多数人在编码时候遇到问题的解决方式是：目视+冥想。

现在的学校主要分为两类：学术性院校和应用型院校，但由于很多学校长期以来的以学术性研究定位，教材和教授方式更倾向于学术研究，导致很多人都习惯于去看书学习和解决一些问题，这样就形成了很大程度上的纸上谈兵的局面。

而真正在工作中的留给我们学习的时间是有限的，所以要求更快速高效的自学能力。比如一家以技术为驱动的公司，要求技术栈的切换很快，前一个项目是 Java 后一个项目就变成了 mobile。对于一个全新的技术栈学习时间可能最多只有一周，那怎么才能在一周的时间里去学习一门新的技术栈呢？大多数同学可能就是说，我先去借一本 XXX 入门看一看，然后再自己编点 demo。我刚开始也是这样的。后来才发现不行，这样子太慢了，而且书上有错误，一不小心就被带沟里去了。

在借书的时候，拿 C++ 语言举例。有 C++语言入门，C++语言实战练习，C++高级语言编程，C++面向对象程序设计……很多很多书，根本不知道借哪一本对不对？在这里应该有这样一个概念，知识是有边界的，同样人也是可以被划分为 senior 和 junior 的。这两者之间的区别就是时间的鸿沟，时间的鸿沟也就是小时数。一万小时理论，只要你花费一万小时在某个领域你就会成为这个领域的专家。所以说设计这样的东西都是 senior 去做的，我们作为 junior 主要去做一些训练和理解，对概念的掌控。



---------

###学习方法

学习应该有思维的框架，那怎么去建立这个思维框架呢？

####第一步，历史
大家都知道，人是故事驱动的动物，如果我给你念一段马克思主义哲学和一个野史的故事，大家应该都会选择故事对不对。每一个事物发展到今天，都会有它自己独特的历史发展趋势，了解历史才会对这个事物有更深刻的理解。

语言也是有发展历史的，几乎所有的现代高级编程语言都是同源的且相互学习的。

Fortran是机器友好的编译型语言, 因为在执行代码前需要提前预编译, 所以不宜出错, 虽然编程的效率高但是可读性非常差. 因为之前计算机的性能很差, 硬件设施非常贵, 人们想方设法节约内存去提高运行效率, 代码变得十分复杂. 经过发展衍生出了 JAVA C C++ 等静态语言。Java 是工业级语言，足够笨，菜鸟也可以写出了而且不会出太大的问题。

Lisp 是人脑友好的解释性语言, 效率高, 但是性能很低. 但是在硬件十分便宜的今天, 人们更愿意去消耗硬件资源来获取更少的时间花费. 在 Lisp 中函数十分重要, 有"函数式一等公民"的说法. 经过发展衍生出来 Ruby JavaScript Pathyn 等脚本语言。

####第二步，代码如何书写
什么是编程呢？就是用过程去操做数据的转化。所以语言通常被分为两个方面，数据和过程。

* 过程  顺序，分支，循环
* 数据  数字 字符 布尔 空值 集合 | 对象 函数

数据和过程是每一个语言共有的，每一门语言都无非是这些东西。但是有一些细节又不是很相同，学习的时候需要注意。

* 数字 精度转化 科学计数法
* 字符 js 使用单引号和双引号
* 布尔 隐式转换显式转换0.1 true false
* 空值 多少种空值 js 3 undefined null nan
* 集合 泛型 数组


####第三步，代码如何保存和加载
学习了代码的书写还要知道代码在哪里写，怎么运行，文件结构，加载方式，运行方式，文件后缀，运行方式。这些都是要搞清楚的问题。IDE 它不是运行方式，它只是一个写代码的环境。

如果文件内相互调用怎么办？？这就是模块化编程，举个例子在 Java 中都是用包去划分职责的，每个包可以看做一个模块，如果这个 A 包用到了 B 包的东西，只需要 import 进来就可以了，对吧。

介绍一个东西，***REPL***

Read-Eval-Print Loop(“读取-求值-输出”循环), 是一个简单的，交互式的编程环境。这个词常常用于指代一个Lisp的交互式开发环境.

比如在命令行里输入 node, irb 可以分别启动 node, ruby 的 REPL. chrome 中的 console 也属于一种 REPL.


####第四步，人脑友好成主流
硬件越来越便宜，相对的来说人力资源越来越贵。解决同样的性能问题，可能使用硬件只需要加一个内存条就可以了，现在的内存条也就是一两百块钱，如果让人去想办法利用算法啊解决性能问题可能就会用一天，两天，这一天两天的时间能买多少内存条了是不是。所以现在人脑友好型的语言成了主流。很多静态语言都在学习动态语言的特点，比如 Java8 引入的函数式编程， 这就是动态语言的一个特点。


####第五步，建立思维索引
人总会遗忘，建立思维索引，比如 API。Java 的文档有那么多的 API，不可能全部都会记住，所以要在脑袋里建立 string 有哪些方法，用的时候再去查找。这样就方便了很多。

Mac dash

Ubuntu zeal

-----

###搜索

对于搜索，只有两点要求 Google + 英文 keyword。用 Google 就要翻墙，如果不能翻墙的话可以使用 bing 和 Yahoo 的英文搜索，效果都比百度要好得多。

那搜索出来了应该重点先看官方的文档，其次是 stackoverflow，最后是一些大牛的博客。如果随便看那个不知名的人的博客，可能他有一天学了一个新东西自己写了个心得说这个多好多好但是自己还没搞清楚，说不定哪天就被一个小白拿去用了，小白加小白。

-----

###学习三大工具

* ####复盘

重复别人讲述的东西，这样一是防止自己跑神，二是印象更深刻。

* ####task

**tasking 是什么?** 一种可以让人快速, 清晰知道你思考问题,解决问题的方式. tasking 也可以说是一种沟通方式.

**tasking 什么时候用?** 在着手编写代码之前, 也就是分析问题的时候用 tasking. 只有分析清楚问题应该如何去, 每一步应该做什么, 在开始编写代码的时候才会有目的性, 不至于出错都找不到原因.

**tasking 用在什么地方?** 分析问题的时候, 需要同其他人将自己思路时.

**为什么要用 tasking?** 方便团队间的沟通交流, 方便别人清楚写 tasking 人的思路, 也可以快速找出隐藏的问题和不合常理处, 方便写测试.

**谁需要用 tasking?** 自己, 团队之间.

* ####pipeline

pipeline 管道思维可以通过水管的工作去理解, 一段水管肯定有一端是进水端一端是出水端, 水管在管道的内部发生了什么样的变化我们是看不到的,但是可以通过多段水管的拼接, 将水源从一处运送到另一处. 在程序中也是一样, 每个函数或者模块可以看做是一段水管, 有输入有输出, 将多段水管拼接起来可定会有这样一种情况, 一端水管的输出是另一端水管的输入.

使用 pipeline 的主要作用有两点: 1.可以从结果倒推回 input,检测思考问题的正确性. 2.在编写代码前, 只需要想清楚大概的处理流程就好, 怎样从输入到输出可以暂时不用考虑.



-----
###推荐
* 5W1H

对某一工作在调查研究的基础上，就其工作内容（What）、责任者（Who）、工作岗位（Where）、工作时间（When）、怎样操作（How）以及为何这样做（Why），进行书面描述，并按此描述进行操作，达到完成职务任务的目标。

如果能把5W1H说清楚，那就算是理解了这个东西。

* xMind

思维导图，可以帮助梳理自己的思维。
